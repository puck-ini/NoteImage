(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{393:function(e,r,t){"use strict";t.r(r);var _=t(44),a=Object(_.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"主从模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#主从模式"}},[e._v("#")]),e._v(" 主从模式")]),e._v(" "),t("p",[e._v("主从模式实际上对应的是读写分离的方式。")]),e._v(" "),t("p",[e._v("Redis 中的读写分离：读操作主库和从库都可以进行，写操作只有主库能进行，写操作只有在主库执行完之后才能同步到从库中。")]),e._v(" "),t("p",[e._v("写操作只在主库是为了防止数据不一致的问题，例如同时修改了主库和从库中的同一个键的数据。")]),e._v(" "),t("blockquote",[t("p",[e._v("读写分离的方式在很多地方都会有应用，例如多线程并发中的读写锁")]),e._v(" "),t("p",[e._v("如果在从库中进行写操作会报错")])]),e._v(" "),t("h2",{attrs:{id:"主从配置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#主从配置"}},[e._v("#")]),e._v(" 主从配置")]),e._v(" "),t("h2",{attrs:{id:"主从之间数据如何同步"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#主从之间数据如何同步"}},[e._v("#")]),e._v(" 主从之间数据如何同步？")]),e._v(" "),t("p",[e._v('从库在启动时回向主库发送 psync 命令，psync 命令包含主库的 runID 和复制进度 offset。如果时第一次发送命令，runID 会设置为"?"，offset 设置为-1表示第一次进行同步。主库接收到命令后会使用 fullresync 命令返回给从库，表示全量复制，之后主库会执行 bgsave 命令生成 RDB 文件发送给从库。从库接受到文件之后首先清空原有的数据，这一步是为了防止从库跟主库数据不一致，之后加载 RDB 文件。主库将数据同步给从库期间还是能继续接收新的指令，这个时候为了保证数据一致性主库会在内存只用一个 replication buffer 缓冲区记录下命令，主库生成完 RDB 文件之后会将文件和缓冲区的命令同步到从库。主从库完成了全量复制，它们之间就会维持一个长连接状态，主库会通过这个连接将之后收到的命令操作同步给从库，长连接可以避免频繁建立连接的开销。')]),e._v(" "),t("h2",{attrs:{id:"网络断开问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#网络断开问题"}},[e._v("#")]),e._v(" 网络断开问题")]),e._v(" "),t("p",[e._v("网络断开问题会导致主库和从库之间服务同步数据，客户端读取数据时会从从库中读取到旧的数据。")]),e._v(" "),t("p",[e._v("在 Redis 2.8 之前，主从库在网络断开重连之后会进行一次全量复制，从上述主从同步的过程知道，一次全量复制需要生成一次 RDB 文件，开销会比较大。")]),e._v(" "),t("p",[e._v("在 Redis 2.8 之后，主从库重连之后会采用增量复制的方式进行同步。增量复制的意思是主库只会把在断开期间接收到的命令同步到从库中，这样就避免了全量复制带来的开销。")]),e._v(" "),t("p",[e._v("增量复制的实现需要维护一个 repl_backlog_buff 环形缓冲区，这个缓冲区在从库连接上主库时就会创建（不是断开重连后，是主从开始时），主库的写命令在同步到从库时也会记录在这个缓冲区中，类似一个日志。")]),e._v(" "),t("p",[e._v("对于repl_backlog_buff 环形缓冲区，主库会把断连时接手到的命令不仅会写在 replication buffer，同时也会写在 repl_backlog_buffer 中。在这个环形缓冲区中主库会记录自己写到的位置（master_repl_offset），从库会记录自己读到的位置（slave_repl_offset）。主库或从库每接收或读取一个新的写命令都会偏离初始位置。")]),e._v(" "),t("p",[e._v("在主从库回复连接时，从库会向主库发送 psync 命令包含 slave_repl_offset，主库会判断 master_repl_offset 和 slave_repl_offset 的差距是决定全量复制还是增量复制。因为环形缓冲区当写入的命令太多会覆盖原有的数据，这时候如果将从库还未读取到的数据覆盖时，就会决定采取全量复制，同时主库写入太快将从库未读取到的数据覆盖也会导致全量复制。如果是因为速度问题导致可以调整 repl_backlog_size 参数将缓冲空将增大。")]),e._v(" "),t("h2",{attrs:{id:"多从库时全量复制问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多从库时全量复制问题"}},[e._v("#")]),e._v(" 多从库时全量复制问题")]),e._v(" "),t("p",[e._v("主从库在建立连接是会进行一次全量复制，全量复制中会进行 RDB 文件的生成和 RDB 文件的传输，这两个过程会消耗很多时间，如果从库的数量很多，导致从库跟主库建立连接时，主库每次都得 fork 子进程去生成 RDB 文件进行全量复制，fork 子进程期间会阻塞主进程处理请求，这样就会导致主库处理请求的效率降低。同时，传输 RDB 文件也会占用主库的网络带宽，给主库的资源使用带来压力。")]),e._v(" "),t("p",[e._v("为了解决上述问题，主从模式可以采取主 - 从 - 从的模式。")]),e._v(" "),t("p",[e._v("图")]),e._v(" "),t("p",[e._v("类似于上述图片所展示的，这样就将多个从库的全量复制转移到了其他从库中。保证了主库不会降低处理请求的效率问题。")]),e._v(" "),t("h2",{attrs:{id:"replication-buffer-和-repl-backlog-buffer-区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#replication-buffer-和-repl-backlog-buffer-区别"}},[e._v("#")]),e._v(" replication buffer 和 repl_backlog_buffer 区别")]),e._v(" "),t("ol",[t("li",[t("strong",[e._v("repl_backlog_buffer")]),e._v("：为了从库断开之后，如何找到主从差异数据而设计的环形缓冲区，从而避免全量同步带来的性能开销。在 repl_backlog_buffer 中找主从差异的数据后，如何发给从库呢？这就用到了replication buffer。")]),e._v(" "),t("li",[t("strong",[e._v("replication buffer")]),e._v("：Redis 和客户端通信也好，和从库通信也好，Redis都需要给分配一个 内存 buffer 进行数据交互，客户端是一个client，从库也是一个 client，我们每个 client 连上Redis后，Redis 都会分配一个client buffer，所有数据交互都是通过这个 buffer 进行的：Redis 先把数据写到这个 buffer 中，然后再把buffer中的数据发到 client socket 中再通过网络发送出去，这样就完成了数据交互。所以主从在增量同步时，从库作为一个 client，也会分配一个 buffer，只不过这个 buffer 专门用来传播用户的写命令到从库，保证主从数据一致，我们通常把它叫做 replication buffer。")])])])}),[],!1,null,null,null);r.default=a.exports}}]);