(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{403:function(v,t,_){"use strict";_.r(t);var r=_(44),e=Object(r.a)({},(function(){var v=this,t=v.$createElement,_=v._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"rpc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rpc"}},[v._v("#")]),v._v(" RPC")]),v._v(" "),_("h2",{attrs:{id:"什么是-rpc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是-rpc"}},[v._v("#")]),v._v(" 什么是 RPC")]),v._v(" "),_("p",[v._v("RPC（Remote Procedure Call）远程过程调用，区别于本地过程调用（类之间的方法调用），RPC 是应用服务之间的方法调用。")]),v._v(" "),_("h2",{attrs:{id:"rpc-框架"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rpc-框架"}},[v._v("#")]),v._v(" RPC 框架")]),v._v(" "),_("p",[v._v("RPC 框架的出现是为了屏蔽远程调用跟本地调用的区别，让我们感觉就是调用项目内的方法，同时隐藏底层网络通信的复杂性，让我们更专注于业务逻辑。")]),v._v(" "),_("p",[v._v("常见的 RPC 框架有：")]),v._v(" "),_("ul",[_("li",[v._v("Dubbo：国内最早开源的 RPC 框架，由阿里巴巴公司开发并于 2011 年末对外开源，仅支持 Java 语言。")]),v._v(" "),_("li",[v._v("Motan：微博内部使用的 RPC 框架，于 2016 年对外开源，仅支持 Java 语言。")]),v._v(" "),_("li",[v._v("gRPC：Google 于 2015 年对外开源的跨语言 RPC 框架，支持多种语言。")])]),v._v(" "),_("p",[v._v("...")]),v._v(" "),_("h3",{attrs:{id:"dubbo"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dubbo"}},[v._v("#")]),v._v(" Dubbo")]),v._v(" "),_("p",[v._v("Apache Dubbo 是一款微服务开发框架，它提供了RPC 通信与微服务治理两大关键能力。")]),v._v(" "),_("p",[_("img",{attrs:{src:"img/RPC/image-20210804172954430.png",alt:"image-20210804172954430"}})]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("节点")]),v._v(" "),_("th",[v._v("角色说明")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[_("code",[v._v("Provider")])]),v._v(" "),_("td",[v._v("暴露服务的服务提供方")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("Consumer")])]),v._v(" "),_("td",[v._v("调用远程服务的服务消费方")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("Registry")])]),v._v(" "),_("td",[v._v("服务注册与发现的注册中心")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("Monitor")])]),v._v(" "),_("td",[v._v("统计服务的调用次数和调用时间的监控中心")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("Container")])]),v._v(" "),_("td",[v._v("服务运行容器")])])])]),v._v(" "),_("h3",{attrs:{id:"motan"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#motan"}},[v._v("#")]),v._v(" Motan")]),v._v(" "),_("p",[v._v("Motan是一套基于java开发的RPC框架，除了常规的点对点调用外，Motan还提供服务治理功能，包括服务节点的自动发现、摘除、高可用和负载均衡等。Motan具有良好的扩展性，主要模块都提供了多种不同的实现，例如支持多种注册中心，支持多种rpc协议等。")]),v._v(" "),_("p",[v._v("Motan中分为服务提供方(RPC Server)，服务调用方(RPC Client)和服务注册中心(Registry)三个角色。")]),v._v(" "),_("ul",[_("li",[v._v("Server提供服务，向Registry注册自身服务，并向注册中心定期发送心跳汇报状态；")]),v._v(" "),_("li",[v._v("Client使用服务，需要向注册中心订阅RPC服务，Client根据Registry返回的服务列表，与具体的Sever建立连接，并进行RPC调用。")]),v._v(" "),_("li",[v._v("当Server发生变更时，Registry会同步变更，Client感知后会对本地的服务列表作相应调整。")])]),v._v(" "),_("p",[v._v("三者的交互关系如下图：")]),v._v(" "),_("p",[_("img",{attrs:{src:"img/RPC/image-20210804212027426.png",alt:"image-20210804212027426"}})]),v._v(" "),_("h3",{attrs:{id:"grpc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#grpc"}},[v._v("#")]),v._v(" gRPC")]),v._v(" "),_("p",[v._v("gRPC 是一个高性能、开源、通用的 RPC 框架，由 Google 推出，基于 HTTP2 协议标准设计开发，默认采用 Protocol Buffers 数据序列化协议，支持多种开发语言。gRPC 提供了一种简单的方法来精确的定义服务，并且为客户端和服务端自动生成可靠的功能库。")]),v._v(" "),_("p",[_("img",{attrs:{src:"img/RPC/image-20210804212518762.png",alt:"image-20210804212518762"}})]),v._v(" "),_("h2",{attrs:{id:"如何实现一个简易的-rpc-框架"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何实现一个简易的-rpc-框架"}},[v._v("#")]),v._v(" 如何实现一个简易的 RPC 框架")]),v._v(" "),_("p",[v._v("RPC 框架是典型的 client/server 架构，一个 RPC 框架基本离不开 registry、client、server 三要素。")]),v._v(" "),_("ul",[_("li",[v._v("registry")])]),v._v(" "),_("p",[v._v("注册中心，提供服务发现和注册功能，保存提供者的服务信息。在 RPC 中，消费者可以直接调用提供者的服务，但是需要知道提供者的连接信息，如果把提供者的信息写死在消费者中，这样会导致整个系统中如果提供者信息变化，例如集群部署会有节点的增删，消费者就无法感知到提供者的变化，因此在 RPC 中需要一个中间层即注册中心提供服务信息。")]),v._v(" "),_("ul",[_("li",[v._v("client")])]),v._v(" "),_("p",[v._v("服务的消费者，调用提供者提供的服务，调用之前需要从注册中心获取提供者服务的信息。")]),v._v(" "),_("ul",[_("li",[v._v("server")])]),v._v(" "),_("p",[v._v("服务的提供者，对外提供服务接口，同时需要将服务信息注册到注册中心中。")]),v._v(" "),_("h3",{attrs:{id:"rpc-中涉及的技术"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rpc-中涉及的技术"}},[v._v("#")]),v._v(" RPC 中涉及的技术")]),v._v(" "),_("p",[v._v("一个 RPC 框架会涉及到的技术有服务注册发现、负载均衡、序列化协议、RPC通信协议、Socket通信、异步调用、熔断降级等。下面实现的 RPC 只会使用到其中的部分技术。")]),v._v(" "),_("ul",[_("li",[v._v("注册中心")])]),v._v(" "),_("p",[v._v("注册中心是为了让消费者能够发现提供者提供的服务，注册中心的选择有很多，例如 Zookeeper、Nacos、Eureka 等等，本实现中选择的是 Zookeeper 和 Nacos，可以在配置中选择切换。")]),v._v(" "),_("ul",[_("li",[v._v("序列化")])]),v._v(" "),_("p",[v._v("序列化的目的是为了将对象持久化到内存或者便于网络传输。RPC 中会涉及到消费者和提供者之间的网络传输。本实现中支持 JDK  序列化、Hessian2、Kryo、Protostuff、Fastjson 序列化实现。")]),v._v(" "),_("ul",[_("li",[v._v("IO通信")])]),v._v(" "),_("p",[v._v("通讯框架选择 Netty，Netty 是一个封装了 NIO 的高性能框架。")]),v._v(" "),_("ul",[_("li",[v._v("动态代理")])]),v._v(" "),_("p",[v._v("动态代理支持 JDK 动态代理以及 CGLIB 的字节码生成实现。")]),v._v(" "),_("ul",[_("li",[v._v("负载均衡")])]),v._v(" "),_("p",[v._v("负载均衡主要有随机以及轮询。")]),v._v(" "),_("ul",[_("li",[v._v("SPI（可选）")])]),v._v(" "),_("p",[v._v("SPI 全称为 (Service Provider Interface) ，是一种服务提供发现机制，JDK 就内置有 SPI 的实现。使用 SPI 是为了方便同一接口的不同实现进行切换。")])])}),[],!1,null,null,null);t.default=e.exports}}]);