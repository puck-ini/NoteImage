(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{385:function(a,t,v){"use strict";v.r(t);var _=v(44),r=Object(_.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"锁类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#锁类型"}},[a._v("#")]),a._v(" 锁类型")]),a._v(" "),v("h2",{attrs:{id:"乐观锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#乐观锁"}},[a._v("#")]),a._v(" 乐观锁")]),a._v(" "),v("p",[a._v("乐观锁是一种乐观思想，即每次处理共享数据时都默认别的线程都不会在进行修改，在写数据时会判断当前数据与期望值是否相同，如果相同才会更新。适用于读多写少的场景。")]),a._v(" "),v("p",[a._v("例如在设计数据库表时会添加一个版本属性，当要更新表的一条数据时首先查出这条数据的版本，假设是0，之后修改数据更新到数据库时判断该数据的版本是否仍然等于0，如果等于就将数据更新到数据库同时版本号加一。如果不等于就表明有其他线程已经更新过该数据，则更新失败。")]),a._v(" "),v("p",[a._v("在 Java 中的乐观锁使用最多的的就是 CAS （Compare And Swap）方法，即比较与判断。")]),a._v(" "),v("p",[a._v("CAS 的缺点")]),a._v(" "),v("ul",[v("li",[a._v("ABA 问题")]),a._v(" "),v("li",[a._v("循环时间长开销大")])]),a._v(" "),v("p",[a._v("CAS 在更新失败是会不停循环执行知道成功，如果长时间不成功会给 CPU 带来非常大的执行开销。")]),a._v(" "),v("ul",[v("li",[a._v("只能保证一个共享变量的原子操作")])]),a._v(" "),v("p",[a._v("当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。")]),a._v(" "),v("blockquote",[v("p",[a._v("从 Java 1.5 开始 JDK 提供了 AtomicReference 类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作。")])]),a._v(" "),v("h2",{attrs:{id:"悲观锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#悲观锁"}},[a._v("#")]),a._v(" 悲观锁")]),a._v(" "),v("p",[a._v("悲观锁是一种悲观思想，即每次操作共享变量时都认为会有其他线程会修改，所以每次操作前都会上锁，其他线程想操作共享变量时获取不到锁只能等待获取锁的线程释放锁。适用于写多读少的场景。")]),a._v(" "),v("h2",{attrs:{id:"自旋锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#自旋锁"}},[a._v("#")]),a._v(" 自旋锁")]),a._v(" "),v("p",[a._v("由于多线程的核心时 CPU 的时间分片，所以同一时间只能有一个线程获取到锁。这个时候获取不到锁的线程可以循环等待判断该锁是否已经被释放，不用将自身阻塞起来，这种锁就叫做自旋锁。")]),a._v(" "),v("p",[a._v("自旋锁的原理比较简单，如果持有锁的线程能在短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞状态，它们只需要等一等(自旋)，等到持有锁的线程释放锁之后即可获取，这样就避免了用户进程和内核切换的消耗。")]),a._v(" "),v("p",[v("a",{attrs:{href:"https://www.cnblogs.com/cxuanBlog/p/11679883.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("看完你就明白的锁系列之自旋锁 - 程序员cxuan - 博客园 (cnblogs.com)"),v("OutboundLink")],1)]),a._v(" "),v("h2",{attrs:{id:"互斥锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#互斥锁"}},[a._v("#")]),a._v(" 互斥锁")]),a._v(" "),v("p",[a._v("互斥锁是获取不到锁的线程将自己阻塞起来，等待重新调度请求。")]),a._v(" "),v("h2",{attrs:{id:"可重入锁-递归锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#可重入锁-递归锁"}},[a._v("#")]),a._v(" 可重入锁（递归锁）")]),a._v(" "),v("p",[a._v("可重入锁，也叫做递归锁，是指在一个线程中可以多次获取同一把锁，比如：一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法，即可重入，而无需重新获得锁。")]),a._v(" "),v("p",[a._v("可重入锁最大的作用是避免死锁。")]),a._v(" "),v("p",[a._v("可重入锁加锁几次就得释放锁几次，不然会导致死锁，例如加锁2次就得释放2次，如果只释放1次会导致程序卡死线程无法出来。")]),a._v(" "),v("p",[a._v("如果加锁1次释放两次运行时会报错。")]),a._v(" "),v("h2",{attrs:{id:"读写锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#读写锁"}},[a._v("#")]),a._v(" 读写锁")]),a._v(" "),v("p",[a._v("读写锁分为读锁和写锁，主要是为了解决锁的性能问题。读锁可以在没有写锁的时候被多个线程同时持有，写锁则是独占的（排他），即可以有多个线程并发的读，但是只能有一个线程写。")]),a._v(" "),v("p",[a._v("读写锁的互斥原则：")]),a._v(" "),v("ul",[v("li",[a._v("读读共存")]),a._v(" "),v("li",[a._v("读写互斥")]),a._v(" "),v("li",[a._v("写写互斥")])]),a._v(" "),v("h2",{attrs:{id:"公平锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#公平锁"}},[a._v("#")]),a._v(" 公平锁")]),a._v(" "),v("p",[a._v("公平锁是可以让多个线程按照申请锁的顺序获取锁。在并发环境中，每个线程会先查看此锁维护的等待队列，如果当前等待队列为空，则占有锁，如果等待队列不为空，则加入到等待队列的末尾，按照 FIFO（先进先出）的原则从队列中拿到线程，然后占有锁。")]),a._v(" "),v("h2",{attrs:{id:"非公平锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#非公平锁"}},[a._v("#")]),a._v(" 非公平锁")]),a._v(" "),v("p",[a._v("非公平锁获取锁的顺序是不定的，多个线程获取锁的顺序，不是按照先到先得的顺序，有可能后申请锁的线程比先申请的线程优先获取锁。")]),a._v(" "),v("p",[a._v("非公平锁的性能高于公平锁，但是有可能造成线程饥饿（某个线程长时间获取不到锁）")]),a._v(" "),v("h2",{attrs:{id:"共享锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#共享锁"}},[a._v("#")]),a._v(" 共享锁")]),a._v(" "),v("p",[a._v("共享锁即可以有多个线程获取到锁，就像之前说的读锁一样。")]),a._v(" "),v("h2",{attrs:{id:"独占锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#独占锁"}},[a._v("#")]),a._v(" 独占锁")]),a._v(" "),v("p",[a._v("只能有一个线程获取锁，以独占的方式持有锁。和悲观锁、互斥锁同义。")]),a._v(" "),v("h2",{attrs:{id:"偏向锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#偏向锁"}},[a._v("#")]),a._v(" 偏向锁")]),a._v(" "),v("p",[a._v("偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。")]),a._v(" "),v("h2",{attrs:{id:"轻量级锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#轻量级锁"}},[a._v("#")]),a._v(" 轻量级锁")]),a._v(" "),v("p",[a._v("是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。")]),a._v(" "),v("h2",{attrs:{id:"重量级锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#重量级锁"}},[a._v("#")]),a._v(" 重量级锁")]),a._v(" "),v("p",[a._v("等待锁的线程都会进入阻塞状态。")]),a._v(" "),v("h2",{attrs:{id:"同步锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#同步锁"}},[a._v("#")]),a._v(" 同步锁")]),a._v(" "),v("p",[a._v("同步锁与互斥锁同义，表示并发执行的多个线程，在同一时间内只允许一个线程访问共享数据。")]),a._v(" "),v("h2",{attrs:{id:"死锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#死锁"}},[a._v("#")]),a._v(" 死锁")]),a._v(" "),v("p",[a._v("如线程A持有资源x，线程B持有资源y，线程A等待线程B释放资源y，线程B等待线程A释放资源x，两个线程都不释放自己持有的资源，则两个线程都获取不到对方的资源，就会造成死锁。")]),a._v(" "),v("h2",{attrs:{id:"活锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#活锁"}},[a._v("#")]),a._v(" 活锁")]),a._v(" "),v("p",[a._v("活锁指的是任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。 活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。")]),a._v(" "),v("p",[a._v("活锁可以认为是一种特殊的饥饿。 下面这个例子在有的文章里面认为是活锁。实际上这只是一种饥饿。因为没有体现出“活”的特点。 假设事务T2再不断的重复尝试获取锁R，那么这个就是活锁。\n如果事务T1封锁了数据R,事务T2又请求封锁R，于是T2等待。T3也请求封锁R，当T1释放了R上的封锁后，系统首先批准了T3的请求，T2仍然等待。然后T4又请求封锁R，当T3释放了R上的封锁之后，系统又批准了T4的请求......T2可能永远等待。\n活锁应该是一系列进程在轮询地等待某个不可能为真的条件为真。活锁的时候进程是不会blocked，这会导致耗尽CPU资源。")]),a._v(" "),v("h2",{attrs:{id:"锁粗化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#锁粗化"}},[a._v("#")]),a._v(" 锁粗化")]),a._v(" "),v("p",[a._v("如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作都是出现在循环体体之中，就算真的没有线程竞争，频繁地进行互斥同步操作将会导致不必要的性能损耗，所以就采取了一种方案：把加锁的范围扩展（粗化）到整个操作序列的外部，这样加锁解锁的频率就会大大降低，从而减少了性能损耗。")]),a._v(" "),v("h2",{attrs:{id:"锁消除"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#锁消除"}},[a._v("#")]),a._v(" 锁消除")]),a._v(" "),v("p",[a._v("就是把锁干掉。当Java虚拟机运行时发现有些共享数据不会被线程竞争时就可以进行锁消除。")]),a._v(" "),v("p",[a._v("如何判断共享数据不会被线程竞争？")]),a._v(" "),v("p",[a._v("利用逃逸分析技术：分析对象的作用域，如果对象在A方法中定义后，被作为参数传递到B方法中，则称为方法逃逸；如果被其他线程访问，则称为线程逃逸。")]),a._v(" "),v("p",[a._v("在堆上的某个数据不会逃逸出去被其他线程访问到，就可以把它当作栈上数据对待，认为它是线程私有的，同步加锁就不需要了。")]),a._v(" "),v("h2",{attrs:{id:"参考"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[a._v("#")]),a._v(" 参考")]),a._v(" "),v("p",[v("a",{attrs:{href:"https://tech.meituan.com/2018/11/15/java-lock.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("不可不说的Java“锁”事 - 美团技术团队 (meituan.com)"),v("OutboundLink")],1)]),a._v(" "),v("p",[v("a",{attrs:{href:"https://juejin.cn/post/6867922895536914446",target:"_blank",rel:"noopener noreferrer"}},[a._v("5000字 | 24张图带你彻底理解Java中的21种锁 (juejin.cn)"),v("OutboundLink")],1)]),a._v(" "),v("p",[v("a",{attrs:{href:"https://baike.baidu.com/item/%E6%B4%BB%E9%94%81/5096375",target:"_blank",rel:"noopener noreferrer"}},[a._v("活锁_百度百科 (baidu.com)"),v("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=r.exports}}]);